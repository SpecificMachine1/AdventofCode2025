(library (day day04)
  (export get-data count-accessible count-all-accessible)
  (import (rnrs base)
          (rnrs lists)
          (rnrs records syntactic)
          (aoc file)
          (aoc matrix))

(define (get-data filename)
  (list->matrix (filename->char-lines filename)))

(define (neighbors matrix i j)
  (let* ((moves '((-1 -1) (-1 0) (-1 1)
                  (0 -1)         (0 1)
                  (1 -1)  (1 0)  (1 1)))
         (abs-locations (map (lambda (move-pair)
                               (list (+ i (car move-pair)) (+ j (cadr move-pair))))
                             moves)))
    (filter (lambda (loc) (and (<= 0 (car loc) (- (matrix-m matrix) 1))
                               (<= 0 (cadr loc) (- (matrix-n matrix) 1))))
            abs-locations)))

(define (count-accessible matrix n)
  (define (add-if-accessible-roll i j acc)
    (let ((this (matrix-element matrix i j)))
      (if (eq? this #\@)
        (let check ((locs (neighbors matrix i j)) (count 0))
          (cond
            ((>= count n) acc)
            ((null? locs) (+ acc 1))
            (else (let ((this-neighbor (apply matrix-element (cons matrix (car locs)))))
                    (if (eq? this-neighbor #\@)
                      (check (cdr locs) (+ count 1))
                      (check (cdr locs) count))))))
        acc)))
  (matrix-fold add-if-accessible-roll 0 matrix))

(define-record-type rolls
  (fields (mutable accessible) (mutable unaccessible)))

(define (count-all-accessible matrix n)
  (define (accessible? i j)
    (let check ((locs (neighbors matrix i j)) (count 0))
          (cond
            ((>= count n) #f)
            ((null? locs) #t)
            (else (let ((this-neighbor (apply matrix-element (cons matrix (car locs)))))
                    (if (eq? this-neighbor #\@)
                      (check (cdr locs) (+ count 1))
                      (check (cdr locs) count)))))))
  (define (first-pass)
    (define (collect-rolls i j acc)
      (let ((this (matrix-element matrix i j)))
        (cond
          ((not (eq? this #\@)) acc)
          ((accessible? i j) (list (cons (list i j) (car acc)) (cadr acc)))
          (else (list (car acc) (cons (list i j) (cadr acc)))))))
    (let ((roll-args (matrix-fold collect-rolls '(() ()) matrix)))
      (make-rolls (car roll-args) (cadr roll-args))))
  (define (remove coords)
    (cond
      ((null? coords) #t)
      (else (matrix-set-element! matrix (caar coords) (cadar coords) #\.)
            (remove (cdr coords)))))
  (define (later-pass old-inventory)
    (define (collect-rolls coord acc)
      (let* ((i (car coord)) (j (cadr coord)) (this (matrix-element matrix i j)))
        (cond
          ((not (eq? this #\@)) acc)
          ((accessible? i j) (list (cons (list i j) (car acc)) (cadr acc)))
          (else (list (car acc) (cons (list i j) (cadr acc)))))))
    (let ((roll-args (fold-right collect-rolls '(() ()) (rolls-unaccessible old-inventory))))
      (make-rolls (car roll-args) (cadr roll-args))))
  (let remove-loop ((inventory #f) (count 0))
    (cond
      ((not inventory) (let ((new-inventory (first-pass)))
                         (remove (rolls-accessible new-inventory))
                         (remove-loop new-inventory (length (rolls-accessible new-inventory)))))
      ((zero? (length (rolls-accessible inventory))) count)
      (else (let ((new-inventory (later-pass inventory)))
              (remove (rolls-accessible new-inventory))
              (remove-loop new-inventory (+ count (length (rolls-accessible new-inventory)))))))))

)
